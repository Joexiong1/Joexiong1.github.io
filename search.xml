<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>变量提升、函数提升</title>
    <url>/2024/01/05/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E3%80%81%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<h3 id="全局作用域的预处理"><a href="#全局作用域的预处理" class="headerlink" title="全局作用域的预处理"></a>全局作用域的预处理</h3><p>预处理（预解析）：JS在解析代码之前，有一个“预处理（预解析）”阶段，将当前 JS 代码中所有变量的定义和函数的定义，放到所有代码的最前面。这种预解析也称之为声明提前（变量提升）</p>
<p>变量提升：在js执行过程中，js引擎把变量的声明和函数的声明提升到代码最顶的行为（会影响程序执行结果，console.log()）。变量被提升后，会给变量设置为默认值，此值为undefined，所以可以在声明之前使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">a = <span class="number">123</span>; <span class="comment">//此时a相当于window.a</span></span><br></pre></td></tr></table></figure>
<p>程序会报错：<code>Uncaught ReferenceError: a is not defined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);  <span class="comment">//打印结果：undefined。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if(false)里面的代码虽然不会被执行，但是整个代码有解析的环节，解析的时候就已经把 变量 i 给提前声明了。</p>
<p>但是如果声明变量时不是用var关键字,比如直接写a&#x3D;1或是使用let和connst定义的变量并不会变量提升，在声明 let 、const变量之前就使用它会导致 ReferenceError。</p>
<p>使用const声明的常量在声明时必须进行初始化。一旦被赋值，常量的值在其生命周期内不能被修改，但是注意，在JavaScript中，对象和数组是引用类型。使用const声明的常量不会使对象和数组的内容不可变，使用const声明的常量只是保证我们不能将arr指向另一个数组，但是可以修改arr指向的数组内部的内容。在 ES2015 之前，JavaScript 是没有块作用域的，只有函数作用域和全局作用域。可以使用 let 关键词声明拥有块作用域的变量。</p>
<p>let和const都是块级作用域，不属于window对象（不能使用window.变量名），同一作用域中不能重复声明，而var是可以重新声明和赋值的，如果只是声明，不改变上一次赋值结果，let和const也不能对var在同一作用域声明，在不同作用域是可以的</p>
<h3 id="函数的声明提前（函数提升）"><a href="#函数的声明提前（函数提升）" class="headerlink" title="函数的声明提前（函数提升）"></a>函数的声明提前（函数提升）</h3><p>使用函数表达式创建的函数const foo &#x3D; function(){}，不会被声明提前，所以不能在声明前调用，因为此时只是变量foo被提升了，且值为undefined，并没有把function{}赋值给foo</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不会报错，可以正常执行函数，正常打印结果</span></span><br><span class="line"><span class="title function_">fun1</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时 fun2 相当于 undefined。执行时会报错：Uncaught ReferenceError: Cannot access &#x27;fun2&#x27; before initialization</span></span><br><span class="line"><span class="title function_">fun2</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明，会被提前声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是 fun1 函数&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式，不会被提前声明</span></span><br><span class="line"><span class="keyword">const</span> fun2 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是 fun12 函数&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意：函数提升优先于变量提升</strong></p>
<p>另外，不仅全局作用域中存在声明提前，在函数作用域中，也有声明提前的现象：</p>
<p>定义形参就相当于在函数作用域中声明了变量，举例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// 这个函数中，因为有了形参 e，此时相当于在函数内部的第一行代码里，写了 var e;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun</span>(); <span class="comment">//打印结果为 undefined</span></span><br><span class="line"><span class="title function_">fun</span>(<span class="number">123</span>); <span class="comment">//打印结果为123</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型转换</title>
    <url>/2024/01/05/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">tostring</span>()</span><br><span class="line"><span class="title function_">string</span>()</span><br><span class="line"><span class="title function_">number</span>()</span><br><span class="line"><span class="built_in">parseInt</span>(string)</span><br><span class="line"><span class="built_in">parseFloat</span>(string)</span><br><span class="line"><span class="title class_">Boolean</span>()</span><br></pre></td></tr></table></figure>

<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p><strong>隐式类型转换，内部调用的都是显式类型的方法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>()</span><br><span class="line"></span><br><span class="line">自增/自减运算符：++、--</span><br><span class="line"></span><br><span class="line">正号/负号：+a、-a</span><br><span class="line"></span><br><span class="line">加号:+</span><br><span class="line"></span><br><span class="line">运算符:-、*、/</span><br><span class="line"></span><br><span class="line"><span class="title function_">toString</span>()函数</span><br><span class="line"></span><br><span class="line">变量.<span class="title function_">toString</span>();</span><br><span class="line">常量.<span class="title function_">toString</span>();  <span class="comment">//常量不能直接写数字，如下</span></span><br><span class="line"><span class="number">1.</span><span class="title function_">toString</span>(); <span class="comment">// 注意，会报错</span></span><br><span class="line"><span class="number">1.</span>.<span class="title function_">toString</span>(); <span class="comment">// 合法。得到的结果是字符串&quot;1&quot;</span></span><br><span class="line"><span class="number">1.2</span>.<span class="title function_">toString</span>(); <span class="comment">// 合法。得到的结果是字符串&quot;1.2&quot;</span></span><br><span class="line">(<span class="number">1</span>).<span class="title function_">toString</span>(); <span class="comment">// 合法。得到的结果是字符串&quot;1&quot;</span></span><br><span class="line"><span class="comment">//又或者直接把常量放到变量中存起来，然后通过变量调用</span></span><br></pre></td></tr></table></figure>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = 变量.<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a6 = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> a7 = <span class="literal">undefined</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a6.<span class="title function_">toString</span>()); <span class="comment">// 报错：Uncaught TypeError: Cannot read properties of null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a7.<span class="title function_">toString</span>()); <span class="comment">// 报错：Uncaught TypeError: Cannot read properties of undefined</span></span><br></pre></td></tr></table></figure>

<p>该方法不会影响到原变量，它会将转换的结果返回。当然我们还可以直接写成**a &#x3D; a.toString()**，这样可以直接修改原变量</p>
<p>对上述常量引用toString()的打印结果的解释</p>
<p> 第一行代码：JS引擎认为1.toString()中的.是小数点，小数点后面的字符是非法的。</p>
<p>第二行、第三行代码：JS引擎认为第一个.是小数点，第二个.是属性访问的语法，所以能正常解释实行。</p>
<p>第四行代码：用()排除了.被视为小数点的语法解释，所以这种写法也能正常解释执行。</p>
<p>另：</p>
<ol>
<li><p>大多数情况下，toString()不接受参数，但是Number类型变量可以传递一个整数作为参数，此时它会把数字转换为指定的进制，如果不指定则默认转换为10进制.</p>
</li>
<li><p>纯小数的小数点后面，如果紧跟连续6个或6个以上的“0”时，那么，将用e来表示这个小数。</p>
</li>
<li><p>常量没有方法，但是可以调用 toString()，因为除了 null、undefined之外，其他的常量都有对应的特殊的引用类型——基本包装类型，所以代码在解释执行的时候，会将常量转为基本包装类型，这样就可以调用相应的引用类型的方法。</p>
</li>
</ol>
<p><strong>String()函数</strong></p>
<p>使用 String()函数做强制类型转换时：</p>
<p>  对于 Number、Boolean、String、Object 而言，本质上就是调用 toString()方法，返回结果同 toString()方法。<br>  但是对于 null 和 undefined，则不会调用 toString()方法。它会将 null 直接转换为 “null”。将 undefined 直接转换为 “undefined”。</p>
<p><strong>隐式类型转换 （特殊）</strong></p>
<p>逻辑运算符：&amp;&amp;、||、! 。非布尔值进行与或运算时，会先将其转换为布尔值，然后再运算。&amp;&amp;、||的运算结果是原值，!的运算结果为布尔值。</p>
<p><a href="https://www.runoob.com/w3cnote/javascript-or-and-and.html">https://www.runoob.com/w3cnote/javascript-or-and-and.html</a></p>
<p>运算结果结论如下： 只要 || 前面为 false,不管 || 后面是 true 还是 false，都返回 || 后面的值。 只要 || 前面为 true,不管 || 后面是 true 还是 false，都返回 || 前面的值。 只要 &amp;&amp; 前面是 false，无论 &amp;&amp; 后面是 true 还是 false，结果都将返 &amp;&amp; 前面的值。 只要 &amp;&amp; 前面是 true，无论 &amp;&amp; 后面是 true 还是 false，结果都将返 &amp;&amp; 后面的值<br>三个及以上的非布尔值，做逻辑运算：<br>与运算的返回结果：（value1 &amp;&amp; value2 &amp;&amp; value3）</p>
<ul>
<li>从左到右依次计算操作数，找到第一个为 false 的值为止。</li>
<li>如果所有的值都为 true，则返回最后一个值。<br>或运算的返回结果：（value1 || value2 || value3）</li>
<li>从左到右依次计算操作数，找到第一个为 true 的值为止。</li>
<li>如果所有的值都为 false，则返回最后一个值。<br>JS中的“&amp;&amp;”属于短路的与：<br>如果第一个值为false，则不会执行后面的内容<br>如果第一个值为true，则继续执行第二条语句，并返回第二个值<br>同时JS中的‘||’属于短路的或：<br>如果第一个值为true，则不会执行后面的内容<br>如果第一个值为false，则继续执行第二条语句，并返回第二个值<br>实际开发中可以借此进行“容错处理”<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result; <span class="comment">// 请求接口时，后台返回的内容</span></span><br><span class="line"><span class="keyword">let</span> errorMsg = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 前端的文案提示</span></span><br><span class="line"><span class="keyword">if</span> (result &amp; result.<span class="property">retCode</span> == <span class="number">0</span>) &#123;</span><br><span class="line">  errorMsg = <span class="string">&#x27;恭喜你中奖啦~&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result &amp;&amp; result.<span class="property">retCode</span> != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">// 接口返回异常码时</span></span><br><span class="line">	errorMsg = result.<span class="property">msg</span> || <span class="string">&#x27;活动太火爆，请稍后再试&#x27;</span>; <span class="comment">// 文案提示信息，优先用 接口返回的msg字段，其次用 &#x27;活动太火爆，请稍后再试&#x27; 这个文案兜底。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!result) &#123;</span><br><span class="line">	<span class="comment">// 接口挂掉时</span></span><br><span class="line">	errorMsg = <span class="string">&#x27;网络异常，请稍后再试&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>关系运算符：&lt;、&gt; &lt;&#x3D; &gt;&#x3D;等。关系运算符，得到的运算结果都是布尔值：要么是 true，要么是 false<br>隐式类型转换</p>
<ol>
<li>隐式转换类型：字符串拼接<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>; <span class="comment">// Number 类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a + <span class="string">&#x27;&#x27;</span>); <span class="comment">// 打印结果：&quot;123&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a + <span class="string">&#x27;haha&#x27;</span>); <span class="comment">// 打印结果：&quot;123haha&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>实际上底层是调用string()函数</p>
<p><strong>Number()函数</strong></p>
<p>字符串→数字 （1）如果字符串中是纯数字，则直接将其转换为数字。 （2）如果字符串是一个空串或者是一个全是空格的字符串，则转换为 0。 （3）只要字符串中包含了其他非数字的内容（一个小数点按数字来算），则转换为 NaN。即使用 Number() 函数之后，如果无法转换为数字，就会转换为 NaN<br>bool→数字 （1）true转成1 （1）true转成0<br>null→数字 结果为0<br>undefined→数字 NaN</p>
<ol start="2">
<li>隐式转换类型：正负号</li>
</ol>
<p>注意是正号&#x2F;负号，不是加号&#x2F;减号。任何值做+a、-a运算时， 底层调用的是 Number() 函数（所以如果对bool值进行+-，结果会是0&#x2F;-0&#x2F;1&#x2F;-1）。不会改变原数值；得到的结果，会改变正负性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a3 = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+a3); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-a3); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>使用parseInt()函数：字符串→整数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="built_in">parseInt</span>(需要转换的字符串)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;110&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>(a, <span class="number">16</span>); <span class="comment">// 【重要】将 a 当成 十六进制 来看待，转换成 十进制 的 num（注意不是转成16进制），结果为272</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>(a, <span class="number">2</span>);  <span class="comment">//转换失败，因为二进制中没有5这个数</span></span><br></pre></td></tr></table></figure>
<p>将传入的数据当作字符串来处理，<strong>从左至右提取数值，一旦遇到非数值就立即停止（包括小数点，所以只取整数）；停止时如果还没有提取到数值，就返回NaN。（所以开头不是数字就会直接返回NaN，如果是空串或者全是空格，会报错）</strong></p>
<p><strong>parseInt()、parseFloat()会将传入的数据当作字符串来处理（就算是数字也会先转为字符串）</strong>。也就是说，如果对非 String使用 parseInt()、parseFloat()，它会先将其转换为 String然后再操作。</p>
</li>
<li><p>parseFloat()函数：字符串→浮点数</p>
<p>parseFloat()和 parseInt()的作用类似，不同的是，parseFloat()可以获得小数部分。</p>
</li>
</ol>
<h3 id="三、转换为Boolean"><a href="#三、转换为Boolean" class="headerlink" title="三、转换为Boolean"></a>三、转换为Boolean</h3><p>   其他的数据类型都可以转换为 Boolean 类型。无论是隐式转换，还是显示转换，转换结果都是一样的。</p>
<p>数字 –&gt; 布尔。 0 和 NaN的转换结果 false，其余的都是 true。比如 Boolean(NaN)的结果是 false。<br>字符串 —&gt; 布尔。空串的转换结果是false，其余的都是 true。全是空格的字符串，转换结果也是 true。字符串’0’的转换结果也是 true。<br>null 和 undefined 都会转换为 false。<br>引用数据类型会转换为 true。注意，空数组[]和空对象{}，转换结果也是 true。</p>
<p>四、隐式类型转换：逻辑运算</p>
<p>const a &#x3D; 1;</p>
<p>console.log(a &#x3D;&#x3D; true); &#x2F;&#x2F; 打印结果：true<br>console.log(typeof a); &#x2F;&#x2F; 打印结果：number。可见，上面一行代码里，a 做了隐式类型转换，但是 a 的数据类型并没有发生变化，仍然是 Number 类型</p>
<p>使用！！</p>
<p>使用 !!可以显式转换为 Boolean 类型。比如 !!3的结果是 true。</p>
<p>其他进制的数字：</p>
<p>16 进制的数字，以0x开头<br>8 进制的数字，以0开头<br>2 进制的数字，0b开头（不是所有的浏览器都支持：chrome 和火狐支持，IE 不支持）</p>
<p><strong>isNaN()函数</strong></p>
<p> 判断指定的参数是否为 NaN（非数字类型），返回结果为 Boolean 类型。也就是说：<strong>任何不能被转换为数值的参数，都会让这个函数返回 true</strong>。</p>
<p><strong>执行过程：</strong></p>
<p>（1）先调用**Number()**函数</p>
<p>（2）然后判断**Number()**的返回结果是否为数值。如果不为数值，则最终结果为 true；如果为数值，则最终结果为 false。</p>
<p>console.log(isNaN(‘null’)); &#x2F;&#x2F; 返回结果：false(因为null的Number（）结果为0)</p>
]]></content>
      <categories>
        <category>JavaScript学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript运行三步曲——解释执行</title>
    <url>/2024/01/06/Javascript%E8%BF%90%E8%A1%8C%E4%B8%89%E6%AD%A5%E6%9B%B2%E2%80%94%E2%80%94%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<p><strong>在分析JS引擎执行之前，需要明确两件事情：</strong></p>
<ol>
<li><p>JS是<strong>单线程</strong>的，为了避免代码解析阻塞使用了异步执行，实现异步执行的机制是事件循环（Event Loop）。</p>
</li>
<li><p>JS虽然是单线程的，但是参与JS执行过程的线程一共有四个，但是只有JS引擎线程在执行JS脚本程序，其他三个线程只负责将满足触发条件的处理函数推进事件队列，等待JS引擎线程执行，不参与代码解析与执行。四个线程分别是：</p>
</li>
</ol>
<p><strong>JS引擎线程</strong>：也称为JS内核，负责解析执行JS脚本程序的主线程（例如V8引擎）。<br><strong>事件触发线程</strong>：归属于浏览器内核进程，不受JS引擎线程控制。主要用于控制事件（例如鼠标，键盘等时间），当该时间被触发时，事件触发线程就会把该事件的处理函数推进事件队列，等待JS引擎线程执行。<br><strong>定时器触发线程</strong>：主要控制计时器setInterval和延时器setTimeout，用于定时器的计时，计时完毕，满足定时器的触发条件，则将定时器的处理函数推进事件队列，等待JS引擎线程执行。（W3C在HTML标准中规定setTimeout低于4ms的时间间隔算为4ms）。<br><strong>HTTP异步请求线程</strong>：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。</p>
<p>注：浏览器对同一域名请求的并发连接数是有限制的，Chrome和Firefox限制数为6个，ie8则为10个。</p>
<p>在JS引擎执行过程中，代码执行顺序如下：宏任务（同步任务）——&gt;微任务——&gt;宏任务（异步任务）</p>
<p>宏任务</p>
<p>宏任务（macro-task）按执行顺序分为同步任务和异步任务：</p>
<ol>
<li><p>同步任务指的是在JS引擎主线程上按顺序执行的任务，只有前一个任务执行完毕后，才能执行后一个任务，形成一个执行栈（函数调用栈）。</p>
</li>
<li><p>异步任务指的是不直接进入JS引擎主线程，而是满足触发条件时，相关的线程将该异步任务推进任务队列（task queue），等待JS引擎主线程上的任务执行完毕，空闲时读取执行的任务，例如异步Ajax，DOM事件，setTimeout等。</p>
</li>
</ol>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>事件循环由三部分组成，分别是：</p>
<ol>
<li><p>主线程执行栈</p>
</li>
<li><p>异步任务等待触发</p>
</li>
<li><p>任务队列</p>
</li>
</ol>
<p>任务队列就是以队列的数据结构对事件任务进行管理，特点是先进先出，后进后出</p>
<p>在JS引擎主线程执行过程中：</p>
<ol>
<li><p>首先执行宏任务的同步任务，在主线程上形成一个执行栈，可理解为函数调用栈。</p>
</li>
<li><p>当执行栈中的函数调用到一些异步执行的API（例如异步Ajax，DOM事件，setTimeout等API），则会开启对应的线程（Http异步请求线程，事件触发线程和定时器触发线程）进行监控和控制。</p>
</li>
<li><p>当异步任务的事件满足触发条件时，对应的线程则会把该事件的处理函数推进任务队列(task queue)中，等待主线程读取执行。</p>
</li>
<li><p>当JS引擎主线程上的任务执行完毕，则会读取任务队列中的事件，将任务队列中的事件任务推进主线程中，按任务队列顺序执行</p>
</li>
<li><p>当JS引擎主线程上的任务执行完毕后，则会再次读取任务队列中的事件任务，如此循环，这就是事件循环（Event Loop）的过程。</p>
</li>
</ol>
<h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2><p>微任务（micro-task）是在ES6和node环境中出现的一个任务类型（其他环境不用考虑），其API主要有:<strong>Promise， process.nextTick</strong>。</p>
<p>在宏任务中执行的任务有两种，分别是同步任务和异步任务，因为异步任务会在满足触发条件时才会推进任务队列（task queue），然后等待主线程上的任务执行完毕，再读取任务队列中的任务事件，最后推进主线程执行，所以这里将异步任务即任务队列看作是新的宏任务。执行的过程如上图所示：</p>
<ol>
<li><p>执行宏任务中同步任务，执行结束。</p>
</li>
<li><p>检查是否存在可执行的微任务，有的话执行所有微任务，然后读取任务队列的任务事件，推进主线程形成新的宏任务；没有的话则读取任务队列的任务事件，推进主线程形成新的宏任务。</p>
</li>
<li><p>执行新宏任务的事件任务，再检查是否存在可执行的微任务，如此不断的重复循环。</p>
</li>
</ol>
<p>以下是一个示例及详细分析：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);</span><br><span class="line"></span><br><span class="line">在该例子中，宏任务的代码部分是：</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>1、代码块通过语法分析和预编译后，进入执行阶段，当JS引擎主线程执行到console.log(‘script start’);，JS引擎主线程认为该任务是同步任务，所以立刻执行输出script start，然后继续向下执行。</p>
<p>2、JS引擎主线程执行到setTimeout(function() { console.log(‘setTimeout’); }, 0);，JS引擎主线程认为setTimeout是异步任务API，则向浏览器内核进程申请开启定时器线程进行计时和控制该setTimeout任务。由于W3C在HTML标准中规定setTimeout低于4ms的时间间隔算为4ms，那么当计时到4ms时，定时器线程就把该回调处理函数推进任务队列中等待主线程执行，然后JS引擎主线程继续向下执行。</p>
<p>3、JS引擎主线程执行到Promise.resolve().then(function() { console.log(‘promise1’); }).then(function() { console.log(‘promise2’); });，JS引擎主线程认为Promise是一个微任务，这把该任务划分为微任务，等待执行。</p>
<p>4、JS引擎主线程执行到console.log(‘script end’);，JS引擎主线程认为该任务是同步任务，所以立刻执行输出script end。</p>
<p>5、主线程上的宏任务执行完毕，则开始检测是否存在可执行的微任务，检测到一个Promise微任务，那么立刻执行，输出promise1和promise2</p>
<p>6、微任务执行完毕，主线程开始读取任务队列中的事件任务setTimeout，推入主线程形成新宏任务，然后在主线程中执行，输出setTimeout</p>
<p>另外，使用setTimeout模拟实现setInterval，是存在一定区别的：</p>
<ol>
<li><p>setTimeout实现setInterval只能通过递归调用。</p>
</li>
<li><p>setTimeout是在到了指定时间的时候就把事件推到任务队列中，只有当在任务队列中的setTimeout事件被主线程执行后，才会继续再次在到了指定时间的时候把事件推到任务队列，那么setTimeout的事件执行肯定比指定的时间要久，具体相差多少跟代码执行时间有关。</p>
</li>
<li><p>setInterval则是每次都精确的隔一段时间就向任务队列推入一个事件，无论上一个setInterval事件是否已经执行，所以有可能存在setInterval的事件任务累积，导致setInterval的代码重复连续执行多次，影响页面性能。</p>
</li>
</ol>
<p><strong>综合以上的分析</strong>，使用setTimeout实现计时功能是比setInterval性能更好的。如果不需要兼容低版本的IE浏览器，使用requestAnimationFrame是更好的选择。</p>
<p><strong>进一步思考</strong>：高频率触发的事件（例如滚动事件）触发频率过高会影响页面性能，甚至造成页面卡顿，可以利用setTimeout实现计时器的原理，对高频触发的事件进行优化，实现点在于将多个触发事件合并成一个，这就是防抖和节流。</p>
]]></content>
      <categories>
        <category>JavaScript学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript运行三步曲——预编译</title>
    <url>/2024/01/06/Javascript%E8%BF%90%E8%A1%8C%E4%B8%89%E9%83%A8%E6%9B%B2%E2%80%94%E2%80%94%E9%A2%84%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>分别对加载完成的代码块进行语法检验，语法正确则进入预编译阶段；不正确则停止该代码块的执行，查找下一个代码块并进行加载，加载完成再次进入该代码块的语法分析阶段。</p>
<h3 id="两个规律"><a href="#两个规律" class="headerlink" title="两个规律"></a>两个规律</h3><p><strong>规律1</strong>：任何变量，如果未经声明就赋值，此变量是属于 window 的属性，而且不会做变量提升。（注意，无论在哪个作用域内赋值）</p>
<p><strong>规律2</strong>：一切声明的全局变量，全是window的属性。（注意，这里说的是在全局作用域内声明的全局变量，不是说局部变量）</p>
<p>window 代表了全局作用域（「代表」而非「等于」）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = b = <span class="number">100</span>; <span class="comment">// 连续赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">b</span>); <span class="comment">//100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">a</span>); <span class="comment">//undefined </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 报错Uncaught ReferenceError:a is not defined</span></span><br></pre></td></tr></table></figure>

<p>代码解释:当执行了foo()函数之后，var a&#x3D;b&#x3D;100这行连续赋值的代码等价于var a&#x3D;(b&#x3D;100),其执行顺序是：</p>
<p>（1）先把100赋值给b</p>
<p>（2）再声明变量a</p>
<p>（3）再把b的值赋值给a</p>
<p>因此，b变量未经声明就被赋值了，此时，根据规律1，这个b是属于window.b,而a的作用域仅限于foo()函数内部，不属于window，所以直接访问会报错，而window.a相当于在window中声明对象a，但未赋值，所以是undefined，但是window.a并不会变量提升</p>
<p>函数预编译，发生在函数执行的前一刻：</p>
<ol>
<li>创建AO对象。AO即Activation Object活跃对象，即执行期上下文</li>
<li>找形参和变量声明，将形参名和变量作为AO的属性名，值为undefined。</li>
<li>将实参值和形参统一，实参的值赋给形参</li>
<li>查找函数声明，函数名作为AO对象的属性</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>a++和++a</title>
    <url>/2024/01/07/++a%E5%92%8Ca++/</url>
    <content><![CDATA[<p>自增分成两种：a++和++a。共同点：</p>
<p>（1）无论是 a++ 还是++a，自增都会使原变量的值加 1。</p>
<p>（2）需要注意的是：a是变量，而a++和++a是表达式。</p>
<p>两者的区别：a++ 和 ++a的值不同：（也就是说，表达式的值不同）</p>
<p>  a++这个表达式的值等于原变量的值（a 自增前的值）。可以这样理解：先把 a 的值赋值给表达式，然后 a 再自增。（比如b&#x3D;a++）<br>  ++a这个表达式的值等于新值 （a 自增后的值）。 可以这样理解：a 先自增，然后把自增后的值赋值给表达式。</p>
<p>–a和a–同理</p>
<p>示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> n2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = n1++;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n1); <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result1); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">result = ++n1;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n1); <span class="comment">//12</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">//12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result2 = n2--;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n2); <span class="comment">// 19</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">result2 = --n2;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n2); <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5地形制作ChatGPT对话-1</title>
    <url>/2024/01/07/UE5%E5%9C%B0%E5%BD%A2%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="与ChatGPT4的对话"><a href="#与ChatGPT4的对话" class="headerlink" title="与ChatGPT4的对话"></a>与ChatGPT4的对话</h2><p><code>You：你了解UE吗</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">GPT:</span><br><span class="line">&quot;UE&quot; 有多种可能的含义，具体取决于上下文。以下是两个常见的含义：</span><br><span class="line"></span><br><span class="line">Unreal Engine (UE):</span><br><span class="line"></span><br><span class="line">简介： Unreal Engine 是由 Epic Games 开发的一款强大的游戏引擎。它广泛用于制作高质量的三维游戏、虚拟现实（VR）、增强现实（AR）、模拟器、可视化效果等应用。Unreal Engine 提供了先进的图形渲染、物理引擎、音频系统等功能，以及基于蓝图和C++的开发环境。</span><br><span class="line">User Experience (UE):</span><br><span class="line"></span><br><span class="line">简介： User Experience（用户体验）是指用户与产品、系统或服务进行交互时的全体经验。它包括用户在使用产品时的感受、情感、满意度等方面。UE 设计关注于创建简单、直观、高效的用户界面，以确保用户在使用产品时有良好的体验。</span><br><span class="line">如果你有特定的问题或是想要深入探讨关于 &quot;UE&quot; 的某个方面，请提供更多的上下文，以便我能够更准确地回答。</span><br></pre></td></tr></table></figure>

<p><code>You:我指的是Unreal Engine</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ChatGPT：了解，Unreal Engine（UE）是一款由 Epic Games 开发的强大游戏引擎，广泛用于电子游戏、虚拟现实（VR）、增强现实（AR）、模拟器等领域。以下是一些关于 Unreal Engine 的基本信息：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 图形引擎： Unreal Engine 包含了先进的图形引擎，支持高质量的实时渲染。其渲染引擎提供了许多先进的功能，如全局光照、实时阴影、体积光、后期处理效果等，以创建逼真的视觉效果。</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 物理引擎： Unreal Engine 集成了强大的物理引擎，支持刚体物理、碰撞检测、布料模拟、液体模拟等，使游戏中的物体和角色具有逼真的运动和互动。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 蓝图系统： Unreal Engine 提供了蓝图系统，这是一种可视化的编程系统，允许开发者使用图形界面设计游戏逻辑和交互，而无需编写代码。蓝图系统使得游戏设计师和艺术家也能够参与到游戏逻辑的创建中。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> 多平台支持： Unreal Engine 支持多个平台，包括 PC、主机（如 PlayStation、Xbox）、移动设备（iOS、Android）、虚拟现实设备（如 Oculus Rift、HTC Vive）等。这使得开发者能够跨多个平台发布他们的作品。</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> 开放性和社区： Unreal Engine 是一个开源引擎，允许开发者访问源代码，并可以根据需要进行修改。此外，Unreal Engine 社区活跃，提供了大量的教程、文档和支持。</span><br><span class="line"></span><br><span class="line"><span class="bullet">6.</span> 游戏开发工具： Unreal Engine 提供了一系列工具，包括场景编辑器、角色编辑器、动画编辑器等，使得游戏开发变得更加高效。</span><br><span class="line"></span><br><span class="line"><span class="bullet">7.</span> 虚拟现实和增强现实： Unreal Engine 是虚拟现实和增强现实应用的重要平台，支持创建逼真的 VR 和 AR 内容。</span><br><span class="line"></span><br><span class="line"><span class="bullet">8.</span> Unreal Engine 在游戏行业和虚拟现实领域广受好评，被许多游戏开发者和工作室选择作为他们的首选引擎。</span><br></pre></td></tr></table></figure>

<p><code>You：你了解UE的关卡制作吗</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ChatGPT：</span><br><span class="line">是的，我了解 Unreal Engine 中的关卡制作。在游戏开发中，关卡是游戏世界的一部分，可以包括地形、建筑、角色、道具等元素。Unreal Engine 提供了强大的关卡编辑工具，允许开发者创建富有创意的游戏场景。</span><br><span class="line"></span><br><span class="line">以下是 Unreal Engine 中关卡制作的一些关键概念和步骤：</span><br><span class="line"></span><br><span class="line">1. 关卡编辑器（Level Editor）： Unreal Engine 的关卡编辑器是一个强大的可视化工具，用于创建、编辑和布置游戏场景。通过关卡编辑器，开发者可以轻松地添加地形、静态网格、光照、效果等元素。</span><br><span class="line"></span><br><span class="line">2. 地形工具： Unreal Engine 的地形工具允许开发者创建自然地形，包括山脉、山谷、平原等。开发者可以使用不同的笔刷和工具来塑造地形，同时可以导入高度图以获取真实的地形数据。</span><br><span class="line"></span><br><span class="line">3. 静态网格和模型： 关卡中的物体通常由静态网格构成，这些网格可以是建筑、道具、植被等。Unreal Engine 支持导入各种3D模型，并提供了灵活的工具来放置、旋转和缩放这些模型。</span><br><span class="line"></span><br><span class="line">4. 蓝图： Unreal Engine 的蓝图系统允许开发者在关卡中创建交互性和逻辑。通过蓝图，开发者可以设计和定义关卡中的游戏逻辑，包括触发事件、角色行为、任务等。</span><br><span class="line"></span><br><span class="line">5. 光照和效果： 光照在游戏中是至关重要的，Unreal Engine 提供了强大的光照系统。开发者可以调整太阳光、灯光、阴影等参数，以实现视觉效果的优化。</span><br><span class="line"></span><br><span class="line">6. 音频： 关卡制作还涉及到音频的布置。开发者可以在关卡中放置音频触发器、背景音乐等，以提供更加丰富的游戏体验。</span><br><span class="line"></span><br><span class="line">7. 碰撞体和触发器： 为了实现游戏中的交互和碰撞检测，开发者可以在关卡中放置碰撞体和触发器。这些元素可以用于处理角色与环境的互动。</span><br><span class="line"></span><br><span class="line">8. 地图优化： 随着关卡的增大，性能优化变得尤为重要。Unreal Engine 提供了一系列的工具和技术，帮助开发者优化关卡，确保游戏在各种平台上都能够运行流畅。</span><br><span class="line"></span><br><span class="line">总体而言，Unreal Engine 的关卡制作工具和特性提供了开发者广泛的创作自由，同时提供了强大的性能和可视化效果。</span><br></pre></td></tr></table></figure>

<p><code>You:我们现在专注于探讨关卡中的地形部分</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ChatGPT:</span><br><span class="line">理解了，让我们专注于关卡中的地形部分。在Unreal Engine中，地形是关卡中一个重要的元素，开发者可以使用地形工具来创建自然的地貌、山脉、河谷等。以下是一些关于Unreal Engine中地形制作的关键概念和步骤：</span><br><span class="line"></span><br><span class="line">1. 地形工具面板： 打开Unreal Engine关卡编辑器后，可以通过选择“Modes”面板中的“Landscape”选项来访问地形工具。这里包含了创建、编辑、涂绘地形的工具。</span><br><span class="line"></span><br><span class="line">2. 创建地形： 首先，你需要创建一个地形。选择“Landscape”选项后，可以选择创建全新的地形或导入高度图。创建地形时，你需要指定地形的大小、分辨率等参数。</span><br><span class="line"></span><br><span class="line">3. 地形编辑工具： 地形编辑工具包括提升、降低、平滑、噪声等功能。这些工具使你能够在地形上进行各种形状和形态的修改，创造出各种地貌。</span><br><span class="line"></span><br><span class="line">4. 涂绘地形： Unreal Engine 允许你使用“涂鸦”工具来为地形添加纹理和细节。这包括添加草地、岩石、沙土等纹理，使地形看起来更加真实。</span><br><span class="line"></span><br><span class="line">5. 雕刻细节： 通过调整地形编辑工具的参数，你可以对地形进行更详细的雕刻，创造出沟壑、山脊等地貌特征。</span><br><span class="line"></span><br><span class="line">6. 高度图导入： Unreal Engine 支持通过导入高度图的方式创建地形。高度图是一种灰度图像，其中不同的灰度值对应不同的高度。这是一个常用的创建真实地形的方法。</span><br><span class="line"></span><br><span class="line">7. 地形材质： 你可以为地形定义多层次的材质，以模拟不同的地表类型。这可以通过材质层的涂抹和混合来实现。</span><br><span class="line"></span><br><span class="line">8. 地形优化： 随着地形的增大，性能优化变得重要。 Unreal Engine 提供了一些工具，如“Landscape LOD”（层次细节）来帮助优化大型地形的性能。</span><br><span class="line"></span><br><span class="line">9. 地形的动态变化： Unreal Engine 还支持在游戏运行时动态修改地形。这意味着你可以在游戏中通过脚本或触发器来修改地形，以响应玩家的行为或故事发展。</span><br><span class="line"></span><br><span class="line">以上是关于 Unreal Engine 中地形制作的一些基本概念和步骤。实际上，地形的制作是一个广泛而深入的主题，你可能需要进一步深入学习和实践以熟练运用这些工具。</span><br></pre></td></tr></table></figure>

<p><code>You:现在我想要知道UE是如何具体实现这些功能的，你可以通过实现思路或是结合UE源码来解答</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ChatGPT:</span><br><span class="line">Unreal Engine（UE）的地形系统是一个复杂而强大的模块，它的实现涉及到多个方面，包括地形生成、编辑、渲染等。下面是对 UE 地形系统实现的一些基本思路和组成部分的简要解释：</span><br><span class="line"></span><br><span class="line">地形生成：</span><br><span class="line"></span><br><span class="line">Unreal Engine 支持通过高度图生成地形。高度图是一种灰度图像，其中灰度值对应地形的高度。在地形生成时，引擎会根据高度图的灰度值为地形的每个顶点计算高度信息，从而形成地形的基本形状。</span><br><span class="line">地形编辑工具：</span><br><span class="line"></span><br><span class="line">地形编辑工具提供了一系列的操作，如提升、降低、平滑、噪声等。这些操作会影响地形的高度信息。实现这些工具的基本思路是通过修改地形的顶点数据，然后更新渲染。</span><br><span class="line">地形的细节涂绘：</span><br><span class="line"></span><br><span class="line">Unreal Engine 允许开发者为地形添加多层次的纹理，这通过涂鸦工具实现。实现思路是为每个地形顶点存储多层次的纹理信息，通过融合这些纹理来模拟地表的不同类型。</span><br><span class="line">地形材质的定义：</span><br><span class="line"></span><br><span class="line">地形的材质定义是通过层次材质（Layered Material）来实现的。每个层次对应一种地表类型，例如草地、岩石、沙土等。这些层次材质通过混合和涂抹操作来达到自然过渡的效果。</span><br><span class="line">LOD（层次细节）：</span><br><span class="line"></span><br><span class="line">Unreal Engine 的地形系统支持 LOD，即在远处时使用低分辨率的地形表示，在近处时逐渐增加细节。这通过在运行时动态生成不同层次的地形网格来实现。</span><br><span class="line">高度图导入：</span><br><span class="line"></span><br><span class="line">高度图导入涉及将外部高度图的灰度信息映射到地形的高度。这通常包括将高度图的像素值映射到地形的顶点高度，并相应地更新地形。</span><br><span class="line">动态变化：</span><br><span class="line"></span><br><span class="line">Unreal Engine 允许在运行时动态修改地形。这是通过在蓝图或代码中实现对地形高度数据的修改和更新来实现的。</span><br><span class="line">在 UE 的实现中，上述功能涉及到底层的图形引擎、渲染管道、材质系统等多个模块。具体的实现细节需要深入阅读 Unreal Engine 的源代码和相关文档。UE 的源代码是闭源的，但 Epic Games 提供了一些开放的接口和文档，以帮助开发者理解和扩展引擎的功能。开发者可以通过 Unreal Engine 的官方文档、社区论坛以及相关的在线资源来深入研究和学习。</span><br></pre></td></tr></table></figure>


<p>在Unreal Engine中，地形制作相关的源码通常位于其主要的GitHub存储库中，具体可以在以下位置找到：</p>
<ul>
<li><strong>存储库</strong>：<a href="https://github.com/EpicGames/UnrealEngine">Unreal Engine GitHub Repository</a></li>
<li><strong>目录路径</strong>：<ul>
<li><code>Engine/Source/Runtime/Landscape/</code>：这个目录包含地形系统（Landscape System）的大部分核心功能和类。</li>
<li><code>Engine/Source/Editor/LandscapeEditor/</code>：这里包含了地形编辑器相关的代码，主要是UE编辑器内用于地形编辑的用户界面和工具。</li>
</ul>
</li>
</ul>
<p>为了访问这些源代码，你需要一个有效的Epic Games账号，并且必须同意Unreal Engine的使用条款。在完成这些步骤之后，你才能够从GitHub存储库克隆或下载代码。</p>
<p>请注意，Unreal Engine的源代码是非常庞大和复杂的，涉及深入的C++编程知识，以及对游戏开发和计算机图形学的理解。如果你刚开始接触这些内容，建议先从官方文档和教程开始学习。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">`You：你了解UE的关卡制作吗`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>是的，我了解《3D Engine Design for Virtual Globes》这本书。这本书由Patrick Cozzi和Kevin Ring共同撰写，专注于3D引擎的设计，特别是用于虚拟地球和地理信息系统（GIS）的应用。它提供了关于如何创建高性能、实时的3D地球可视化引擎的深入讨论和指导。</p>
<p>以下是这本书的一些关键特点和内容概述：</p>
<h3 id="关键特点"><a href="#关键特点" class="headerlink" title="关键特点"></a>关键特点</h3><ol>
<li><strong>实时3D引擎设计</strong>：书中详细探讨了实时渲染技术，特别是在地理空间数据和大规模地球表面渲染方面的应用。</li>
<li><strong>虚拟地球技术</strong>：详细介绍了虚拟地球技术的核心概念，包括地球表面的渲染、地形表示、以及与卫星图像的集成。</li>
<li><strong>性能优化</strong>：重点关注性能优化策略，以确保3D引擎能够高效地处理大量的地理空间数据。</li>
</ol>
<h3 id="内容概述"><a href="#内容概述" class="headerlink" title="内容概述"></a>内容概述</h3><ul>
<li><strong>基础理论</strong>：介绍3D图形学的基础理论，如坐标系统、投影和视图变换。</li>
<li><strong>地理空间数据处理</strong>：讨论如何处理和优化地理空间数据，包括地形数据和卫星图像。</li>
<li><strong>高级渲染技术</strong>：深入探讨高级渲染技术，如着色器编程、光照和阴影、以及大气和天气效果。</li>
<li><strong>地形和图像金字塔</strong>：介绍地形和图像金字塔技术，这是一种处理和显示大规模地理数据的有效方法。</li>
<li><strong>网络技术</strong>：探讨如何使用网络技术来流式传输和渲染地球数据。</li>
</ul>
<h3 id="适用读者"><a href="#适用读者" class="headerlink" title="适用读者"></a>适用读者</h3><ul>
<li><strong>游戏开发者</strong>：对于想要在游戏中实现地球或大规模地形渲染的开发者。</li>
<li><strong>GIS专业人士</strong>：GIS领域的专业人士，希望了解3D引擎在地理空间数据可视化中的应用。</li>
<li><strong>计算机图形学爱好者</strong>：对3D图形学和实时渲染技术感兴趣的读者。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>《3D Engine Design for Virtual Globes》是一本专业的技术书籍，它结合了计算机图形学理论和实际的应用案例，适合那些希望深入了解和开发用于虚拟地球和GIS应用的3D引擎的读者。<br>&#96;&#96;&#96;</p>
]]></content>
      <categories>
        <category>UE5</category>
      </categories>
      <tags>
        <tag>UE5</tag>
        <tag>ChatGPT</tag>
      </tags>
  </entry>
  <entry>
    <title>GIS面经1</title>
    <url>/2024/01/07/GIS%E9%9D%A2%E7%BB%8F/GIS%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<ul>
<li><strong>在openLayers中如何加载WMTS服务?</strong><br><strong>答</strong>: 在openLayers中可以通过olsourse.WMTS 以及 ol.sourse.XYZ等方式加载WMTS服务，ol.source.XYZ的方式比较简单，只需要输入修改url和xyz以及坐标系即可。而ol.source.WMTS较复杂，需要配置原点、分辨率数组、分辨率对应的级别、坐标系的参数等。</li>
</ul>
<p><strong>WMS和WMTS的区别</strong><br><strong>答</strong>:WMTS服务和WMS服务本质区别即对客户端请求服务的响应不同。在接受客户端请求WMTS服务时，返回给客户端是固定大小的瓦片，客户端根据索引号来获取每一张瓦片，而后拼接成地图进行展示，其采取缓存技术来替代实时对数据进行可视化，用以提高地图响应能力。而当客户端请求WMS服务时，返回给客户端是一张完整的图片，客户端取到直接展示。</p>
<p>细节</p>
<h3 id="WMS（Web-Map-Service）"><a href="#WMS（Web-Map-Service）" class="headerlink" title="WMS（Web Map Service）"></a>WMS（Web Map Service）</h3><ol>
<li><strong>动态请求</strong>：WMS 提供地图作为对特定请求的响应。当用户请求地图时，服务器动态生成地图图像并返回。这意味着地图是实时生成的。</li>
<li><strong>灵活性</strong>：WMS 允许用户指定多种参数，如图像大小、格式、地理范围（bounding box）、图层等，从而提供高度定制化的地图。</li>
<li><strong>性能</strong>：由于地图是按需生成的，对于大量用户或复杂的地图渲染，WMS 可能在性能上存在限制。特别是在缩放和平移地图时，可能会出现延迟。</li>
<li><strong>标准和支持</strong>：WMS 是 OGC（Open Geospatial Consortium）的一个标准，得到广泛支持和应用。</li>
</ol>
<h3 id="WMTS（Web-Map-Tile-Service）"><a href="#WMTS（Web-Map-Tile-Service）" class="headerlink" title="WMTS（Web Map Tile Service）"></a>WMTS（Web Map Tile Service）</h3><ol>
<li><strong>预渲染瓦片</strong>：WMTS 使用预先渲染的地图瓦片。这些瓦片在多个尺度级别上生成，并存储在服务器上。</li>
<li><strong>性能优化</strong>：由于地图瓦片是预先生成的，WMTS 在性能上通常优于 WMS，尤其是在处理大量请求时。地图的加载和显示更快，用户体验更流畅。</li>
<li><strong>可缓存性</strong>：预渲染的瓦片可以被缓存，这对于常访问的地区和流行的尺度级别非常有用，进一步提高了性能。</li>
<li><strong>灵活性限制</strong>：与 WMS 相比，WMTS 提供的灵活性较低。用户不能自定义地图的尺寸或样式，只能选择预定义的瓦片。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>WMS 适用于需要高度定制的地图服务，允许动态生成地图，但可能在性能上有限制。</li>
<li>WMTS 更适用于需要快速响应和高并发的场景，通过使用预渲染的地图瓦片提供优化的性能，但牺牲了一定的灵活性。</li>
</ul>
<p><strong>Web端如何实时获取服务器数据</strong></p>
<ul>
<li>Worker</li>
<li>Ajax+定时器</li>
</ul>
<p><strong>OGC有哪些服务</strong><br><strong>答</strong>：</p>
<ul>
<li><strong>WMS(Web Map Service)：地图服务</strong></li>
</ul>
<p>⽤于获取地图图像，以便在Web上进⾏显示。WMS服务通常允许⽤户以各种格式(若PNG，JPEG 等)检索地图图像。</p>
<ul>
<li><strong>WFS(Web Feature Service)：矢量服务</strong></li>
</ul>
<p>⽤于获取地理空间数据，以便在Web上进⾏分析和查询，WFS服务通常允许⽤户以多种格式(如GML，JSON等)检索地理空间数据。</p>
<p>具体代码表现层⾯：如加载geojson数据</p>
<ul>
<li><strong>WCS(Web Coverage Service)：栅格服务</strong></li>
</ul>
<p>⽤于获取遥感数据和其他覆盖范围数据。WCS服务允许⽤户以各种格式（如GeoTIFF、NetCDF 等）检索遥感数据。</p>
<ul>
<li><strong>WMTS（Web Map Tile Service）：地图瓦片服务</strong></li>
</ul>
<p>它是OGC的⼀种服务，⽤于提供已切割为⼩图块的地图图像，以便在Web上进⾏显示。与WMS不 同，WMTS不会动态⽣成地图图像，⽽是将地图预先切割为固定⼤⼩的图块，并将其存储在服务器上。客户端可以请求特定级别和坐标的特定图块，⽽⽆需请求整个地图图像。这样可以提⾼地图显示的效率和速度，特别是在处理⼤规模地图时。</p>
<p><strong>地图投影类型的区别，如何分类</strong><br><strong>答</strong>:</p>
<ol>
<li>等⾯积投影（Equal Area Projection）：这种投影类型会保持地图上的⾯积⽐例不变，但会导致形状和⽅向的变形。常⻅的等⾯积投影包括⻨卡托投影和兰勃托投影。</li>
<li>等⻆投影（Conformal Projection）：这种投影类型会保持地图上的⻆度不变，但会导致⾯积和⻓度的变形。常⻅的等⻆投影包括墨卡托投影和极射投影。</li>
<li>等距投影（Equidistant Projection）：这种投影类型会保持地图上的距离⽐例不变，但会导致⾯积和形状的变形。常⻅的等距投影包括正轴等距投影和正射等距投影。</li>
<li>综合性投影（Composite Projection）：这种投影类型是以上三种投影类型的组合。综合性投影通常⽤于需要平衡多个因素的地图，如形状、⾯积和距离。</li>
</ol>
<p>不同的地图投影类型适⽤于不同的应⽤场景。在选择地图投影类型时，需要考虑需要表达的信息类型、地图区域的⼤⼩和形状、地图的⽤途等因素。</p>
<p><strong>常⻅的空间数据库有哪些</strong></p>
<ul>
<li><strong>PostgreSQL&#x2F;PostGIS</strong>：PostgreSQL是⼀种开源的对象关系型数据库管理系统，⽽PostGIS则是⼀ 个⽤于PostgreSQL的空间数据库扩展，可以⽤于存储、查询和分析空间数据。</li>
<li><strong>Oracle Spatial</strong>：Oracle Spatial是Oracle数据库的⼀个扩展，它提供了存储和查询空间数据的功 能，包括⼏何对象类型、空间索引和空间查询操作。</li>
<li><strong>SQL Server Spatial</strong>：SQL Server Spatial是Microsoft SQL Server数据库的⼀个扩展，它提供了存 储和查询空间数据的功能，包括⼏何对象类型、空间索引和空间查询操作。</li>
<li><strong>SQLite&#x2F;SpatiaLite</strong>：SQLite是⼀种轻型的嵌⼊式关系型数据库管理系统，⽽SpatiaLite则是⼀个⽤ 于SQLite的空间数据库扩展，可以⽤于存储、查询和分析空间数据。</li>
<li><strong>MongoDB</strong>：MongoDB是⼀个NoSQL数据库，它可以存储各种类型的数据，包括空间数据。 MongoDB通过GeoJSON格式存储空间数据，并提供了⼀些空间查询操作。</li>
<li><strong>MySQL Spatial</strong>：MySQL Spatial是MySQL数据库的⼀个扩展，它提供了存储和查询空间数据的功 能，包括⼏何对象类型、空间索引和空间查询操作。</li>
</ul>
<p><strong>地图上要素很多加载慢,遇到过崩掉的情况么前端是如何缓解的</strong><br>前端在处理大量要素时，确实可能会遇到加载缓慢、卡顿、崩溃等问题。以下是一些缓解这些问题的方法：</p>
<ul>
<li><strong>数据优化</strong>：将不必要的数据过滤掉，只加载必要的数据。例如，如果地图上只需要显示某些特定的区 域或点，可以通过缩放或其他⽅式进⾏筛选，只加载这些要素。这样可以减轻数据量，加快加载速度。(<strong>比如在openlayers中可以使用集群（Cluster）</strong>)<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个群集源并设置距离</span></span><br><span class="line"><span class="keyword">const</span> clusterSource = <span class="keyword">new</span> <span class="title class_">Cluster</span>(&#123;</span><br><span class="line">  <span class="attr">distance</span>: <span class="number">40</span>, <span class="comment">// 群集的距离阈值，单位为像素</span></span><br><span class="line">  <span class="attr">source</span>: source,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><strong>图层分级</strong>：将地图逐层分级，每层只显示特定的要素，降低⼀层图层中的要素数量。可以通过层叠效果来叠加多层图层，形成完整的地图效果。这样能够<strong>减少对单个图层的渲染次数</strong>，提⾼性能。</li>
<li><strong>后台优化</strong>：通过后台对数据进⾏剪裁和压缩，减⼩数据传输的⼤⼩。还可以在后台对数据进⾏分块， 分段加载，来减轻前端负担。</li>
<li><strong>瓦⽚地图</strong>：将地图切分成瓦⽚，只显示在当前屏幕可视范围内的瓦⽚，减少了不必要的数据加载。该 技术可以⼤⼤减少加载速度，特别是在⼤地图并发⽤户请求⾮常⾼的情况下。</li>
<li><strong>前端优化</strong>：通过缓存、预加载等技术，优化前端的性能。例如，可以将⼀些经常使⽤的数据进⾏缓存(<strong>比如上一次选中的是哪个地图</strong>)，提⾼响应速度，还可以在⽤户浏览过⼀个⻚⾯时，预加载下⼀个即将进⼊的⻚⾯，以提⾼⽤户体验。</li>
</ul>
<p><strong>动态投影</strong><br><strong>答</strong>:GIS的动态投影跟图形学的动态投影并不相同。在地理信息系统（GIS）中，动态投影（Dynamic Projection）通常指的是在地图上随着用户的交互或数据展示需求，实时地调整地图的投影方式，以便在不同的投影下正确显示地理数据。动态投影在GIS中是一个重要的功能，它允许用户在不同的投影之间切换，以满足不同的分析、展示和交互需求。</p>
]]></content>
      <categories>
        <category>GIS面经</category>
      </categories>
      <tags>
        <tag>GIS面经</tag>
      </tags>
  </entry>
</search>
